function [outstim] = loadstim(stim)%lammestim/loadstim%%% everything is setup by loadstim for movement of both figure and ground,% but stimulus' typenumber determinus which parts actually move% this takes more memory, but it was by far the easiest way to ensure% that the onset stimuli are identical for all cases.%% if gnddirection=NaN, figdirection is used for gndirection%%% lamme modulation index: (4+5)/(3+6)%% 2010-2012, Alexander Heimel%StimWindowGlobals;NewStimGlobals;if NS_PTBv>=3    outstim = loadstimPTB3(stim);	return;end;stim = unloadstim(stim);  % unload old version before loadingparams = stim.params;% make typenumber explicit% interpret typenumberswitch params.typenumber    case 1 % | figdirection    | no              | yes        params.figure_moves = 1;    params.reverse_figdirection = 0;        params.ground_moves = 0;   params.reverse_gnddirection = 0;        params.fixed_aperture = 1;    case 2 % | no              | gnddirection    | yes        params.figure_moves = 0;   params.reverse_gnddirection = 0;        params.ground_moves = 1;    params.reverse_figdirection = 0;        params.fixed_aperture = 1;    case 3 % | figdirection    | gnddirection    | no        params.figure_moves = 1;    params.reverse_figdirection = 0;        params.ground_moves = 1;    params.reverse_gnddirection = 0;        params.fixed_aperture = 1;    case 4 % | figdirection    | gnddirection+180| yes        params.figure_moves = 1;    params.reverse_figdirection = 0;        params.ground_moves = 1;    params.reverse_gnddirection = 1;        params.fixed_aperture = 1;    case 5 % | figdirection+180| gnddirection    | yes        params.figure_moves = 1;    params.reverse_figdirection = 1;        params.ground_moves = 1;    params.reverse_gnddirection = 0;        params.fixed_aperture = 1;    case 6 % | figdirection+180| gndirection+180 | no        params.figure_moves = 1;    params.reverse_figdirection = 1;        params.ground_moves = 1;    params.reverse_gnddirection = 1;        params.fixed_aperture = 1;    case 7 % | figdirection    | no              | yes        params.figure_moves = 1;    params.reverse_figdirection = 0;        params.ground_moves = 0;   params.reverse_gnddirection = 0;        params.fixed_aperture = 0;    case 8 % | figdirection    | gnddirection    | no        params.figure_moves = 1;    params.reverse_figdirection = 0;        params.ground_moves = 1;    params.reverse_gnddirection = 0;        params.fixed_aperture = 0;    otherwise        params.figure_moves = 1;        params.reverse_figdirection = 0;        params.ground_moves = 0;        params.reverse_gnddirection = 0;        % change nothingendif isnan(params.gndspeed)	params.gndspeed = params.figspeed;endif isnan(params.gnddirection)	params.gnddirection = params.figdirection;endif isnan(params.figtextureparams(4))	params.figtextureparams(4) = params.figdirection;endif isnan(params.gndtextureparams)	params.gndtextureparams = params.figtextureparams;endif isnan(params.figorientation)	params.figorientation = params.figdirection;endif isnan(params.movement_duration)	if params.movement_onset>=0		params.movement_duration = params.duration - params.movement_onset;	else		params.movement_duration = 0;	endend		if params.reverse_figdirection    params.figdirection = params.figdirection + 180;endif params.reverse_gnddirection     params.gnddirection = params.gnddirection + 180;endwidth  = params.rect(3) - params.rect(1);height = params.rect(4) - params.rect(2);% set initial random staterand('state',params.randState); %#ok<RAND>% set BG, figure and ground colors%max_intensity_color = [255 255 255];figbg_rgb = params.figbg;figtxt_rgb = figbg_rgb * (1+ params.figcontrast );gndbg_rgb = params.gndbg;gndtxt_rgb = gndbg_rgb * (1+params.gndcontrast);clut_bg = repmat(params.BG,256,1);clut_usage = [ ones(1,8) zeros(1,255-8) ]';transpt_clrind  = 0; %    000, not used as color by itselffigtxt_clrind = 7; % 111figbg_clrind = 3; % 011gndtxt_clrind  = 2; % 010gndbg_clrind  = 1; % 001% with srcCopy as copy mode this, makes it possible to give the figure any% possible shape, where on the figure offscreen the background gets the% transparent colorclut = repmat(params.BG,256,1);clut(figtxt_clrind+1,:) = figtxt_rgb;clut(figbg_clrind+1,:) = figbg_rgb;clut(gndtxt_clrind+1,:) = gndtxt_rgb;clut(gndbg_clrind+1,:) = gndbg_rgb;dp = getdisplayprefs(stim.stimulus);dps = struct(dp);% params.framerate contains the stimulus framerate% this is lower than monitor rate to reduce memory loadn_frames = ceil(params.duration * params.framerate);n_still_frames_before_movement = round(params.movement_onset * params.framerate);n_still_frames_without_figure = round( min(params.figure_onset, params.movement_onset) * params.framerate);n_movement_frames = round(params.movement_duration * params.framerate);n_movement_frames_without_figure = round(max(0,(params.figure_onset - params.movement_onset)) * params.framerate);n_still_frames_after_movement = n_frames - n_still_frames_before_movement - n_movement_frames;ShowStimScreen;% set ground stimulus% compute moving direction rotation matrixangle = (-params.gnddirection+270) * pi /180;rotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute motion vectorunit_motion_per_frame = NewStimViewingDistance * 2 *tan(1/2 * pi/180) * pixels_per_cm  / params.framerate;unit_motion_per_frame = -(rotation * [unit_motion_per_frame; 0])'; % in pixels, minus is to match periodicstimgndmotion_per_frame = unit_motion_per_frame * params.gndspeed;  % in pixelsgndtotalmovingdistance = gndmotion_per_frame * n_movement_frames;gndrectwidth = params.rect(3) - params.rect(1)+ abs(gndtotalmovingdistance(1))*2; % factor 2 is to use same rect for both forward and reverse motiongndrectheight = params.rect(4) - params.rect(2) +abs(gndtotalmovingdistance(2))*2; % factor 2 is to use same rect for both forward and reverse motion% make large offscreen with ground stimulusoffscreen_gnd = Screen(StimWindow,'OpenOffscreenWindow',255,[0 0 gndrectwidth gndrectheight]);fillwithtexture(offscreen_gnd, gndtxt_clrind, gndbg_clrind,  params.gndtextureparams)% set figure stimulusfigwidth_pixels = NewStimViewingDistance * 2 *tan(params.figsize(1) /2 * pi/180) * pixels_per_cm;figheight_pixels = NewStimViewingDistance * 2 *tan(params.figsize(2) /2 * pi/180) * pixels_per_cm;% compute figure orientation rotation matrixangle = -params.figorientation * pi /180;rotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute figure outlineif params.figshape == 2 % polygon	figpolygon = params.figpolygon;else	figpolygon = [0 0;		figwidth_pixels 0; ...		figwidth_pixels figheight_pixels;...		0 figheight_pixels;		0 0];end% rotate outlinefigpolygon = (rotation * figpolygon')';figpolygon = figpolygon - repmat(min(figpolygon),size(figpolygon,1),1); % to make positions positivefigrect = [min(figpolygon) max(figpolygon)];% compute moving direction rotation matrixangle = (-params.figdirection+270) * pi /180;rotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];% compute figure motion vectorunit_motion_per_frame = NewStimViewingDistance * 2 *tan(1/2 * pi/180) * pixels_per_cm  / params.framerate ;unit_motion_per_frame = -(rotation * [unit_motion_per_frame; 0])'; % in pixels, minus is to match periodicstimfigmotion_per_frame = unit_motion_per_frame * params.figspeed;  % in pixels% compute total figure motion to extend figure windowfigtotalmovingdistance = figmotion_per_frame * (n_movement_frames-n_movement_frames_without_figure);figtotalrect = figrect + [0 0 abs(figtotalmovingdistance(1)) abs(figtotalmovingdistance(2))]*2; % factor 2 is to use same rect for both forward and reverse motion% make large offscreen with figure stimulusoffscreen_fig = Screen(StimWindow,'OpenOffscreenWindow',255,figtotalrect);% make screen transparentScreen(offscreen_fig,'FillRect',transpt_clrind);% set drawing region, dependent on stimulus shapefillwithtexture(offscreen_fig, figtxt_clrind, figbg_clrind,  params.figtextureparams)%gndpos = min([0 0],-gndmotion_per_frame*n_movement_frames);% CHECK NEXT STATEMENT: 2010-08-19gndpos = -abs(gndmotion_per_frame)*n_movement_frames;figpos = params.figcenter - mean(figpolygon);offscreen = zeros(1,n_frames);% make still frame (f=1) without figure% new offscreenoffscreen(1) = Screen(StimWindow,'OpenOffscreenWindow',255,[0 0 width height]);% copy ground to offscreenScreen('CopyWindow',offscreen_gnd,offscreen(1),...	[-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)],[0 0 width height]);% make still frame (f=2) with figure% new offscreenoffscreen(2) = Screen(StimWindow,'OpenOffscreenWindow',255,[0 0 width height]);% copy ground to offscreenScreen('CopyWindow',offscreen_gnd,offscreen(2),...	[-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)],[0 0 width height]);% take region in figure src image that will not cross the imageboundary during% the movement%srcfigrect = figrect + repmat(figtotalmovingdistance.*(figtotalmovingdistance>0),1,2)% CHECK NEXT STATEMENT: 2010-08-19srcfigrect = figrect + repmat(abs(figtotalmovingdistance),1,2);% set drawing regionswitch params.figshape	case 1 % oval		if params.figorientation ~= 0			disp('Figure orientation is ignored for oval shape.');		end		figdrawingregion = figrect + [figpos figpos];		shapeFlag = 1;	case {0,2} % rect , polygon		figdrawingregion = figpolygon + repmat(figpos,size(figpolygon,1),1);		shapeFlag = 2;end% copy figure to offscreenScreen(offscreen(2),'SetDrawingRegion',figdrawingregion,shapeFlag);Screen('CopyWindow',offscreen_fig,offscreen(2),...	srcfigrect,[figpos figpos] + figrect,'srcOr');for f=3:n_movement_frames+3 % moving frames	% ground movement	if params.ground_moves		gndpos = gndpos + gndmotion_per_frame;	end			% new offscreen	offscreen(f) = Screen(StimWindow,'OpenOffscreenWindow',255,[0 0 width height]);	% copy ground to offscreen	Screen('CopyWindow',offscreen_gnd,offscreen(f),...		[-gndpos(1) -gndpos(2) width-gndpos(1) height-gndpos(2)],[0 0 width height]);	if f-2 >n_movement_frames_without_figure		% figure movement		if params.figure_moves			if params.fixed_aperture				srcfigrect = srcfigrect - [figmotion_per_frame figmotion_per_frame];			else							% then entire figure moves, and thus the figdrawingregion				figdrawingregion = figdrawingregion + repmat( figmotion_per_frame,size(figdrawingregion,1),1);				figpos = figpos + repmat( figmotion_per_frame,size(figpos,1),1);			end		end		% copy figure to offscreen		Screen(offscreen(f),'SetDrawingRegion',figdrawingregion,shapeFlag);		Screen('CopyWindow',offscreen_fig,offscreen(f),...			srcfigrect,[figpos figpos] + figrect,'srcOr');			endend;% now translate into movie with refreshrate set by monitor% set framerate if there is open stimscreenif ~isempty(StimWindowRefresh)	dps.fps = StimWindowRefresh; % monitor framerateelse	error('LAMMESTIM/LOADSTIM: StimWindowRefresh is empty');endrefreshes_per_frame = dps.fps / params.framerate;%dps.frames = [...%	1*ones(1,n_still_frames_without_figure) ...%	2*ones(1,n_still_frames-n_still_frames_without_figure) ...%	3:n_movement_frames+1 ];dps.frames = [...	1*ones(1, round( n_still_frames_without_figure * refreshes_per_frame) ) ...	2*ones(1, round( (n_still_frames_before_movement-n_still_frames_without_figure) * refreshes_per_frame)   ) ...	round(linspace(3,n_movement_frames+3,(n_movement_frames-1)*refreshes_per_frame)) ...	(n_movement_frames+3)*ones(1, round( n_still_frames_after_movement * refreshes_per_frame))	];if isfield(dps,'defaults')	dps = rmfield(dps,'defaults');endstim = setdisplayprefs(stim,displayprefs(struct2vararg(dps)));dS = {'displayType', 'Movie', 'displayProc', 'standard', ...	'offscreen', offscreen, 'frames', n_frames, 'depth', 8, ...	'clut_usage', clut_usage, 'clut_bg', clut_bg, 'clut', clut};outstim = stim;outstim.stimulus = setdisplaystruct(outstim.stimulus,displaystruct(dS));outstim.stimulus = loadstim(outstim.stimulus);returnfunction fillwithtexture(offscreen, txtcolor, bgcolor,textureparams)%NewStimGlobalsrect = Screen(offscreen,'Rect');rectwidth = rect(3)-rect(1);rectheight = rect(4)-rect(2);% compute texture elementstxtwidth = textureparams(1);txtlength = textureparams(2);txtdensity = textureparams(3);txtangle = textureparams(4);% compute rotation matrixangle = (-txtangle) * pi /180; % convert to degreesrotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];txtwidth_pixels = NewStimViewingDistance * 2*tan(txtwidth/2 *pi/180) * pixels_per_cm;txtlength_pixels = NewStimViewingDistance * 2*tan( txtlength/2 *pi/180) * pixels_per_cm;%txtextend = abs(rotation * [txtwidth_pixels txtlength_pixels]' )';txtarea = 2*txtlength_pixels*2*txtwidth_pixels;number_of_txts_to_fill_rect = rectheight * rectwidth / txtarea;n_txts = ceil(txtdensity * number_of_txts_to_fill_rect);%rf_clearance_radius_pixels = NewStimViewingDistance * 2* tan( params.rf_clearance_radius/2 *pi/180) * pixels_per_cm;txtbasepoints =...	[ -txtwidth_pixels -txtlength_pixels; ...	-txtwidth_pixels +txtlength_pixels; ...	+txtwidth_pixels +txtlength_pixels; ...	+txtwidth_pixels -txtlength_pixels ];txtbasepoints = (rotation * txtbasepoints')';txtpoints = cell(n_txts,1);for i = 1:n_txts	center_clear = 0;	while ~center_clear		%gndcenter = [gndrectleft+gndrectwidth*rand(1) gndrecttop+gndrectheight*rand(1)];%		txtcenter = [rectwidth*rand(1) rectheight*rand(1)]; % genereate random position		% still need to add full extend to this		txtpoints{i} = txtbasepoints + repmat(round(txtcenter),4,1);		center_clear = 1;		%		for j=1:4		%			if norm(txtpoints{i}(j,:)-params.figcenter) < rf_clearance_radius_pixels		%				center_clear = 0;		%				break;		%			end		%		end	endend% set background colorScreen(offscreen,'FillRect',bgcolor);  % becomes different when figure shape is different% draw texture stimulifor i=1:n_txts	Screen(offscreen,'FillPoly',txtcolor,txtpoints{i});end