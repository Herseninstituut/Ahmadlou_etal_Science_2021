function [outstim] = loadstimPTB3(stim)%lammestim/loadstimPTB3%%% everything is setup by loadstim for movement of both figure and ground,% but stimulus' typenumber determinus which parts actually move% this takes more memory, but it was by far the easiest way to ensure% that the onset stimuli are identical for all cases.%% if gnddirection=NaN, figdirection is used for gndirection%%% lamme modulation index: (4+5)/(3+6)%% 2012-2015, Alexander Heimel%StimWindowGlobals;NewStimGlobals;stim = unloadstim(stim);  % unload old version before loadingparams = stim.params;params.figphase = 0;params.gndphase = 0;% interpret typenumberswitch params.typenumber    case 0 % | figdirection    | no              | yes        params.figure_moves = 1;    params.rotate_figdirection = 0;        params.ground_moves = 0;   params.rotate_gnddirection = 0;        params.fixed_aperture = 1;        params.gndsize = 0;    case 1 % | figdirection    | no              | yes        params.figure_moves = 1;    params.rotate_figdirection = 0;        params.ground_moves = 0;   params.rotate_gnddirection = 0;        params.fixed_aperture = 1;    case 2 % | no              | gnddirection    | yes        params.figure_moves = 0;   params.rotate_gnddirection = 0;        params.ground_moves = 1;    params.rotate_figdirection = 0;        params.fixed_aperture = 1;    case 3 % | figdirection    | gnddirection    | no        params.figure_moves = 1;    params.rotate_figdirection = 0;        params.ground_moves = 1;    params.rotate_gnddirection = 0;        params.fixed_aperture = 1;    case 4 % | figdirection    | gnddirection+180| yes        params.figure_moves = 1;    params.rotate_figdirection = 0;        params.ground_moves = 1;    params.rotate_gnddirection = 180;        params.fixed_aperture = 1;    case 5 % | figdirection+180| gnddirection    | yes        params.figure_moves = 1;    params.rotate_figdirection = 180;        params.ground_moves = 1;    params.rotate_gnddirection = 0;        params.fixed_aperture = 1;    case 6 % | figdirection+180| gndirection+180 | no        params.figure_moves = 1;    params.rotate_figdirection = 180;        params.ground_moves = 1;    params.rotate_gnddirection = 1;        params.fixed_aperture = 1;    case 7 % | figdirection    | no              | yes        params.figure_moves = 0;    params.rotate_figdirection = 0;        params.ground_moves = 1;   params.rotate_gnddirection = 0;        params.fixed_aperture = 0;  params.figcontrast=0;    case 8 % | figdirection    | gnddirection    | no        params.figure_moves = 1;    params.rotate_figdirection = 0;        params.ground_moves = 1;    params.rotate_gnddirection = 0;        params.fixed_aperture = 0;      case 9 %  | figdirection    | gnddirection +90| no        params.figure_moves = 1;    params.rotate_figdirection = 0;        params.ground_moves = 1;    params.rotate_gnddirection = 90;        params.fixed_aperture = 0;      case 10% no fig pres.| gnddirection         | no fig. pres.        params.figure_moves = 1;    params.rotate_figdirection = 0;        params.ground_moves = 1;    params.rotate_gnddirection = 0;        params.fixed_aperture = 0;  params.figcontrast = 0;    case 11 % | figdirection + phaseshift   | gnddirection    | yes        params.figure_moves = 1;    params.rotate_figdirection = 0;        params.ground_moves = 1;    params.rotate_gnddirection = 0;        params.fixed_aperture = 1;    otherwise        params.figure_moves = 1;        params.rotate_figdirection = 0;        params.ground_moves = 0;        params.rotate_gnddirection = 0;        % change nothingend% fill in NaN parametersif isnan(params.gndspeed)    params.gndspeed = params.figspeed;endif isnan(params.gnddirection)    params.gnddirection = params.figdirection;endif isnan(params.figtextureparams(4))    params.figtextureparams(4) = params.figdirection;endif isnan(params.gndtextureparams)    params.gndtextureparams = params.figtextureparams;    params.gndtextureparams(4) = params.gnddirection;endif isnan(params.figorientation)    params.figorientation = params.figdirection;endif isnan(params.movement_duration)    if params.movement_onset>=0        params.movement_duration = params.duration - params.movement_onset;    else        params.movement_duration = 0;    endendparams.figdirection = mod(params.figdirection + params.rotate_figdirection,360);params.figphase = params.figphase + params.rotate_figdirection; % to match org for 180 deg turnparams.gnddirection = mod(params.gnddirection + params.rotate_gnddirection,360);params.gndphase = params.gndphase + params.rotate_gnddirection;% to match org for 180 deg turnif length(params.gndtextureparams)>4    params.gndphase = params.gndphase + params.gndtextureparams(5);endif length(params.figtextureparams)>4    params.figphase = params.figphase + params.figtextureparams(5);endif params.typenumber==11    params.figphase = params.figphase + 180;end% set texture or gratingif isfield(params,'imageType') && ~isempty(params.imageType) && params.imageType~=9    usegrating = true;    imageType = params.imageType;else    usegrating = false;endwidth  = params.rect(3) - params.rect(1);height = params.rect(4) - params.rect(2);if usegrating    try % test presence of necessary libraries        [offscreen_test ] = CreateProceduralGrating(StimWindow,10,10,[0.5 0.5 0.5 2],10,0.5,imageType);    catch me        if strcmp(me.message(1:6),'Assert') || strcmp(me.identifier,'MATLAB:invalidMEXFile')            disp(['LAMMESTIM/LOADSTIMPTB3: ' me.message]);            disp('Possibly install glut by ''sudo apt-get install freeglut3''');            return        end        rethrow(me)    endend% set initial random staterand('state',params.randState); %#ok<RAND>% set BG, figure and ground colorsfigbg_rgb = params.figbg;figtxt_rgb = figbg_rgb * (1+ params.figcontrast );gndbg_rgb = params.gndbg;gndtxt_rgb = gndbg_rgb * (1+params.gndcontrast);clut_bg = repmat(params.BG,256,1);clut_usage = [];clut = repmat( (0:255)',1,3);% check MovieParams2MTIds_userfield.Movie_globalalphas = [];ds_userfield.Movie_sourcerects = [];ds_userfield.Movie_auxparameters = [];dp = getdisplayprefs(stim.stimulus);dps = struct(dp);% params.framerate contains the stimulus framerate% this is lower than monitor rate to reduce memory load% but with PTB3 it is no longer necessary and thus no longer used.n_frames = ceil(params.duration * StimWindowRefresh);n_still_frames_before_movement = round(params.movement_onset * StimWindowRefresh);n_still_frames_without_figure = round( min(params.figure_onset, params.movement_onset) * StimWindowRefresh);n_movement_frames = round(params.movement_duration * StimWindowRefresh);n_movement_frames_without_figure = round(max(0,(params.figure_onset - params.movement_onset)) * StimWindowRefresh);n_still_frames_after_movement = n_frames - n_still_frames_before_movement - n_movement_frames;ShowStimScreen;unit_motion_per_frame = NewStimViewingDistance * 2 *tan(1/2 * pi/180) * pixels_per_cm  / StimWindowRefresh;% set ground stimulusgnddestwidth = round(width * abs(sin(params.gnddirection*pi/180)) + height * abs(cos(params.gnddirection*pi/180)));gnddestheight = round(height * abs(sin(params.gnddirection*pi/180)) + width * abs(cos(params.gnddirection*pi/180)));if usegrating    gndmotion_per_frame = 0;else    gndmotion_per_frame = unit_motion_per_frame * params.gndspeed;  % in pixelsendgndtotalmovingdistance = abs(gndmotion_per_frame) * n_movement_frames;gndrectwidth = gnddestwidth + gndtotalmovingdistance*2; % factor 2 is to use same rect for both forward and rotated motiongndrectheight = gnddestheight;% make large offscreen with ground stimulusif usegrating    gnddestwidth = round(width * 3);    gnddestheight = round(width * 3);    if isfield(params,'gndsize')        radius_pixels = round(NewStimViewingDistance * 2 *tan(params.gndsize(1) /2 * pi/180) * pixels_per_cm)/2;    else        radius_pixels = inf;    end        [offscreen_gnd, gndgratingrect] = CreateProceduralGrating(StimWindow,...        gnddestwidth,gnddestwidth,[0.5 0.5 0.5 2],radius_pixels,0.5,imageType);        sf_cpd = 1/(2*params.gndtextureparams(2));    sf_cpp = sf_cpd / (NewStimViewingDistance * tan (1/180*pi)) /pixels_per_cm; % SF in cycles per pixel    contrast = params.gndcontrast;    % set center of figure to phase 0    phase = params.gndphase -360*gnddestwidth/2*sf_cpp ; % degrees    gnd_auxparameters = [phase,sf_cpp,contrast,0];    gnd_tf = params.gndspeed * sf_cpd;    gnddestrect = [-gnddestwidth/2 -gnddestheight/2 gnddestwidth/2 gnddestheight/2] + ...        [params.figcenter(1) params.figcenter(2) params.figcenter(1) params.figcenter(2)];else    gndrectheight = round(gndrectheight);    gndrectwidth = round(gndrectwidth);    offscreen_gnd = Screen('MakeTexture',StimWindow,zeros(gndrectheight+1,gndrectwidth+1,'uint8'));    fillwithtexture(offscreen_gnd, gndtxt_rgb, gndbg_rgb,  params.gndtextureparams)    gnd_auxparameters = [ 0 0 0 0];    gnddestrect = [-gnddestwidth/2 -gnddestheight/2 gnddestwidth/2 gnddestheight/2] + ...        [width/2 height/2 width/2 height/2];end% set figure stimulusfigwidth_pixels = round(NewStimViewingDistance * 2 *tan(params.figsize(1) /2 * pi/180) * pixels_per_cm);figheight_pixels = round(NewStimViewingDistance * 2 *tan(params.figsize(2) /2 * pi/180) * pixels_per_cm);figdestwidth = figwidth_pixels * abs(sin(params.figdirection*pi/180)) + figheight_pixels * abs(cos(params.figdirection*pi/180));figdestheight = figheight_pixels * abs(sin(params.figdirection*pi/180)) + figwidth_pixels * abs(cos(params.figdirection*pi/180));if usegrating    figmotion_per_frame = 0;else    figmotion_per_frame = unit_motion_per_frame * params.figspeed;  % in pixelsendfigtotalmovingdistance = abs(figmotion_per_frame) *  (n_movement_frames-n_movement_frames_without_figure);figrectwidth = figdestwidth + figtotalmovingdistance*2; % factor 2 is to use same rect for both forward and rotated motionfigrectheight = figdestheight;% make large offscreen with figure stimulusif usegrating    switch params.figshape        case 0 % rect            radius = 2*figwidth_pixels; % in pixels        case 1 % oval            radius = round(figwidth_pixels/2); % in pixels            %radius = round(figwidth_pixels); % in pixels        otherwise            error(['LAMMESTIM/LOADSTIMPTB3: Figure shape ' num2str(params.figshape) ' is not implemented.']);    end        [offscreen_fig, figgratingrect] = CreateProceduralGrating(StimWindow,...        figwidth_pixels,figwidth_pixels,[0.5 0.5 0.5 2],radius,0.5,imageType);    sf_cpd = 1/(2*params.figtextureparams(2));    sf_cpp = sf_cpd / (NewStimViewingDistance * tan (1/180*pi)) /pixels_per_cm; % SF in cycles per pixel    contrast = params.figcontrast;    % set center of figure to phase 0    phase = params.figphase -360*figwidth_pixels/2*sf_cpp ; % degrees    fig_auxparameters = [phase,sf_cpp,contrast,0];    fig_tf = params.figspeed * sf_cpd;    figdestrect = CenterRectOnPoint(figgratingrect,params.figcenter(1),params.figcenter(2));else    figrectheight = round(figrectheight);    figrectwidth = round(figrectwidth);    offscreen_fig = Screen('MakeTexture',StimWindow,zeros(figrectheight+1,figrectwidth+1,'uint8'));    % set drawing region, dependent on stimulus shape    tempfigtext = params.figtextureparams;    tempfigtext(4) = tempfigtext(4) - params.figorientation;    fillwithtexture(offscreen_fig, figtxt_rgb, figbg_rgb,  tempfigtext)    fig_auxparameters = [0 0 0 0];    figdestrect = [-figdestwidth/2 -figdestheight/2 figdestwidth/2 figdestheight/2] + ...        [params.figcenter(1) params.figcenter(2) params.figcenter(1) params.figcenter(2)];endif usegrating    figpos = [0 0];    gndpos = [0 0];else    figpos = [abs(gndmotion_per_frame)*(n_movement_frames-n_movement_frames_without_figure) 0]  ;    gndpos = [abs(gndmotion_per_frame)*n_movement_frames 0];end% Make frames% texture 1 is background% texture 2 is figuretexgnd = 1;texfig = 2;% make still frame without figurefor f = 1:n_still_frames_without_figure    ds_userfield.Movie_textures{f} = texgnd;    if usegrating        ds_userfield.Movie_sourcerects(:,f,texgnd) = gndgratingrect;    else        ds_userfield.Movie_sourcerects(:,f,texgnd) = [gndpos gndpos+[gnddestwidth gnddestheight]];    end    ds_userfield.Movie_destrects(:,f,texgnd) = gnddestrect;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gnddirection+90;    ds_userfield.Movie_auxparameters(:,f,texgnd) = gnd_auxparameters;end% make still frames with ground and figurefor f = (n_still_frames_without_figure+1) : n_still_frames_before_movement    ds_userfield.Movie_textures{f} = [texgnd texfig];    if usegrating        ds_userfield.Movie_sourcerects(:,f,texgnd) = gndgratingrect;    else        ds_userfield.Movie_sourcerects(:,f,texgnd) = [gndpos gndpos+[gnddestwidth gnddestheight]];    end    ds_userfield.Movie_destrects(:,f,texgnd) = gnddestrect;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gnddirection+90;    ds_userfield.Movie_auxparameters(:,f,texgnd) = gnd_auxparameters;        if usegrating        ds_userfield.Movie_sourcerects(:,f,texfig) = figgratingrect;    else        ds_userfield.Movie_sourcerects(:,f,texfig) = [figpos figpos+[figdestwidth figdestheight]];    end    ds_userfield.Movie_destrects(:,f,texfig) = figdestrect;    ds_userfield.Movie_globalalphas(1,f,texfig) = 1;    ds_userfield.Movie_angles(1,f,texfig) = params.figdirection+90;    ds_userfield.Movie_auxparameters(:,f,texfig) = fig_auxparameters;endfor f=(n_still_frames_before_movement+1):(n_movement_frames+n_still_frames_before_movement+1) % moving frames    % ground movement    if params.ground_moves        if usegrating            gnd_auxparameters(1) = gnd_auxparameters(1)  + gnd_tf / StimWindowRefresh * 360;        else            gndpos = gndpos + [gndmotion_per_frame 0];        end    end        % copy ground    ds_userfield.Movie_textures{f} = [texgnd texfig];    if usegrating        ds_userfield.Movie_sourcerects(:,f,texgnd) = gndgratingrect;    else        ds_userfield.Movie_sourcerects(:,f,texgnd) = [gndpos gndpos+[gnddestwidth gnddestheight]];    end    ds_userfield.Movie_destrects(:,f,texgnd) = gnddestrect;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gnddirection+90;    ds_userfield.Movie_auxparameters(:,f,texgnd) = gnd_auxparameters;        if f-n_still_frames_before_movement >n_movement_frames_without_figure        % figure movement        if params.figure_moves            if usegrating                fig_auxparameters(1) = fig_auxparameters(1)  + fig_tf / StimWindowRefresh * 360;            else                figpos = figpos + [figmotion_per_frame 0];            end        end                % copy figure to offscreen        if usegrating            ds_userfield.Movie_sourcerects(:,f,texfig) = figgratingrect;        else            ds_userfield.Movie_sourcerects(:,f,texfig) = [figpos figpos+[figdestwidth figdestheight]];        end        ds_userfield.Movie_destrects(:,f,texfig) = figdestrect;%         disp('LAMMESTIM/LOADSTIMPTB3: Looming stimulus');%         ds_userfield.Movie_destrects(:,f,texfig) = figdestrect*f/(n_movement_frames+n_still_frames_before_movement+1);                        ds_userfield.Movie_globalalphas(1,f,texfig) = 1;        ds_userfield.Movie_angles(1,f,texfig) = params.figdirection+90;        ds_userfield.Movie_auxparameters(:,f,texfig) = fig_auxparameters;            endend;for f=(n_movement_frames+n_still_frames_before_movement+2):(n_movement_frames+n_still_frames_before_movement+1)  +n_still_frames_after_movement% moving frames    ds_userfield.Movie_textures{f} = [texgnd texfig];    if usegrating        ds_userfield.Movie_sourcerects(:,f,texgnd) = gndgratingrect;    else        ds_userfield.Movie_sourcerects(:,f,texgnd) = [gndpos gndpos+[gnddestwidth gnddestheight]];    end    ds_userfield.Movie_destrects(:,f,texgnd) = gnddestrect;    ds_userfield.Movie_globalalphas(1,f,texgnd) = 1;    ds_userfield.Movie_angles(1,f,texgnd) = params.gnddirection+90;    ds_userfield.Movie_auxparameters(:,f,texgnd) = gnd_auxparameters;        if usegrating        ds_userfield.Movie_sourcerects(:,f,texfig) = figgratingrect;    else        ds_userfield.Movie_sourcerects(:,f,texfig) = [figpos figpos+[figdestwidth figdestheight]];    end    ds_userfield.Movie_destrects(:,f,texfig) = figdestrect;    ds_userfield.Movie_globalalphas(1,f,texfig) = 1;    ds_userfield.Movie_angles(1,f,texfig) = params.figdirection+90;    ds_userfield.Movie_auxparameters(:,f,texfig) = fig_auxparameters;end% now translate into movie with refreshrate set by monitor% set framerate if there is open stimscreenif ~isempty(StimWindowRefresh)    dps.fps = StimWindowRefresh; % monitor framerateelse    error('LAMMESTIM/LOADSTIM: StimWindowRefresh is empty');endn_frames = size(ds_userfield.Movie_sourcerects,2);dps.frames = (1:n_frames);if isfield(dps,'defaults')    dps = rmfield(dps,'defaults');endif 0    disp('LAMMESTIM/LOADSTIMPTB3: Working on clipping outside surround');    PSstim = periodicstim('default');    PSparams = getparameters(PSstim);    PSparams.rect = StimWindowRect;    PSparams.size = 20;    PSparams.windowShape = 1;    PSparams.nCycles = n_frames/StimWindowRefresh*PSparams.tFrequency;    PSstim = periodicstim(PSparams);    if PSparams.windowShape>-1        [clip_image,clip_dest_rect,ds_clipuserfield] = makeclippingrgn(PSstim);        clip_tex = Screen('MakeTexture',StimWindow,clip_image);        for i=1:n_frames, ds_clipuserfield.Movie_textures{i} = 1; end;                dS_clip = { 'displayType', 'Movie', 'displayProc', 'standard', ...            'offscreen', clip_tex, 'frames', n_frames, 'clut_usage', clut_usage, 'depth', 8, ...            'clut_bg', clut_bg, 'clut', clut, 'clipRect', [] , 'makeClip', 0,'userfield',ds_clipuserfield };        DS_clip = displaystruct(dS_clip);        dp_clip = {'fps',StimWindowRefresh,'rect',clip_dest_rect,'frames',1:n_frames,PSparams.dispprefs{:} };        DP_clip = displayprefs(dp_clip);        moviefields_clip = MovieParams2MTI(DS_clip,DP_clip);        ds_userfield = MovieParamsCat(ds_userfield,moviefields_clip);    end;else    clip_tex = [];endstim = setdisplayprefs(stim,displayprefs(struct2vararg(dps)));dS = {'displayType', 'Movie', 'displayProc', 'standard', ...    'offscreen', [offscreen_gnd,offscreen_fig,clip_tex], 'frames', n_frames, 'depth', 8, ...    'clut_usage', clut_usage, 'clut_bg', clut_bg, 'clut', clut, ...    'clipRect', [] , 'makeClip', 0,'userfield',ds_userfield };outstim = stim;outstim.stimulus = setdisplaystruct(outstim.stimulus,displaystruct(dS));outstim.stimulus = loadstim(outstim.stimulus);disp('LAMMESTIM/LOADSTIMPTB3: Stimulus loaded');returnfunction fillwithtexture(offscreen, txtcolor, bgcolor,textureparams)%NewStimGlobalsrect = Screen(offscreen,'Rect');rectwidth = rect(3)-rect(1);rectheight = rect(4)-rect(2);% compute texture elementstxtwidth = textureparams(1);txtlength = textureparams(2);txtdensity = textureparams(3);txtangle = textureparams(4);% compute rotation matrixangle = pi/2; % convert to degreesrotation = [ cos(angle) sin(angle); -sin(angle) cos(angle)];txtwidth_pixels = NewStimViewingDistance * 2*tan(txtwidth/2 *pi/180) * pixels_per_cm;txtlength_pixels = NewStimViewingDistance * 2*tan( txtlength/2 *pi/180) * pixels_per_cm;txtarea = 2*txtlength_pixels*2*txtwidth_pixels;number_of_txts_to_fill_rect = rectheight * rectwidth / txtarea;n_txts = ceil(txtdensity * number_of_txts_to_fill_rect);txtbasepoints =...    [ -txtwidth_pixels -txtlength_pixels; ...    -txtwidth_pixels +txtlength_pixels; ...    +txtwidth_pixels +txtlength_pixels; ...    +txtwidth_pixels -txtlength_pixels ];txtbasepoints = (rotation * txtbasepoints')';txtpoints = cell(n_txts,1);for i = 1:n_txts    center_clear = 0;    while ~center_clear        txtcenter = [rectwidth*rand(1) rectheight*rand(1)]; % genereate random position        % still need to add full extend to this        txtpoints{i} = txtbasepoints + repmat(round(txtcenter),4,1);        center_clear = 1;    endend% set background colorScreen(offscreen,'FillRect',bgcolor);  % becomes different when figure shape is different% draw texture stimulifor i=1:n_txts    Screen(offscreen,'FillPoly',txtcolor,txtpoints{i});end